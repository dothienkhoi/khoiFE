import { useState, useCallback, useEffect } from 'react'
import { videoCallService, VideoCallResponse } from '@/lib/video-call-service'

export interface VideoCallState {
    isOutgoingCallOpen: boolean
    isIncomingCallOpen: boolean
    recipientName: string
    recipientAvatar?: string
    callerName: string
    callerAvatar?: string
    callDuration: number
    isRinging: boolean
    // Th√™m c√°c tr∆∞·ªùng m·ªõi cho video call th·ª±c t·∫ø
    conversationId?: number
    sessionId?: string
    livekitToken?: string
    livekitServerUrl?: string
    isConnecting: boolean
    error?: string
}

export interface VideoCallActions {
    startOutgoingCall: (recipientName: string, conversationId: number, recipientAvatar?: string) => void
    startIncomingCall: (callerName: string, sessionId: string, callerAvatar?: string) => void
    cancelCall: () => void
    acceptCall: () => void
    rejectCall: () => void
    closeModals: () => void
    // Th√™m c√°c action m·ªõi
    onCallAccepted: () => void
    onCallRejected: () => void
    onCallEnded: () => void
    retryOutgoingCall: () => void
}

export const useVideoCall = (): [VideoCallState, VideoCallActions] => {
    const [state, setState] = useState<VideoCallState>({
        isOutgoingCallOpen: false,
        isIncomingCallOpen: false,
        recipientName: '',
        recipientAvatar: undefined,
        callerName: '',
        callerAvatar: undefined,
        callDuration: 0,
        isRinging: false,
        conversationId: undefined,
        sessionId: undefined,
        livekitToken: undefined,
        livekitServerUrl: undefined,
        isConnecting: false,
        error: undefined
    })

    // Callback functions
    const onCallAccepted = useCallback(async () => {
        console.log('‚úÖ Call accepted callback')

        try {
            if (state.sessionId) {
                // G·ªçi API ƒë·ªÉ l·∫•y token cho ng∆∞·ªùi g·ªçi
                const response = await videoCallService.getCallerToken(state.sessionId)

                if (response.success) {
                    setState(prev => ({
                        ...prev,
                        livekitToken: response.data.livekitToken,
                        livekitServerUrl: response.data.livekitServerUrl,
                        isRinging: false,
                        isConnecting: false,
                        error: undefined
                    }))

                    console.log('‚úÖ Caller token received successfully')
                    // TODO: Chuy·ªÉn ƒë·∫øn LiveKit client v·ªõi token
                } else {
                    throw new Error(response.message || 'Failed to get caller token')
                }
            }
        } catch (error) {
            console.error('Error getting caller token:', error)
            setState(prev => ({
                ...prev,
                error: error instanceof Error ? error.message : 'Failed to get caller token',
                isConnecting: false
            }))
        }
    }, [state.sessionId])

    const onCallRejected = useCallback(() => {
        console.log('‚ùå Call rejected callback')

        setState(prev => ({
            ...prev,
            isOutgoingCallOpen: false,
            isRinging: false,
            callDuration: 0,
            error: 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi'
        }))
    }, [])

    const onCallEnded = useCallback(() => {
        console.log('üîö Call ended callback')

        setState(prev => ({
            ...prev,
            isOutgoingCallOpen: false,
            isRinging: false,
            callDuration: 0,
            error: 'Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c'
        }))
    }, [])

    // Auto-close timer effect
    useEffect(() => {
        let timer: NodeJS.Timeout

        if ((state.isOutgoingCallOpen || state.isIncomingCallOpen) && state.isRinging && !state.error) {
            timer = setTimeout(() => {
                if (state.isOutgoingCallOpen) {
                    cancelCall()
                } else if (state.isIncomingCallOpen) {
                    rejectCall()
                }
            }, 5000)
        }

        return () => {
            if (timer) clearTimeout(timer)
        }
    }, [state.isOutgoingCallOpen, state.isIncomingCallOpen, state.isRinging, state.error])

    // Call duration timer effect
    useEffect(() => {
        let interval: NodeJS.Timeout

        if ((state.isOutgoingCallOpen || state.isIncomingCallOpen) && state.isRinging && !state.error) {
            interval = setInterval(() => {
                setState(prev => ({
                    ...prev,
                    callDuration: prev.callDuration + 1
                }))
            }, 1000)
        }

        return () => {
            if (interval) clearInterval(interval)
        }
    }, [state.isOutgoingCallOpen, state.isIncomingCallOpen, state.isRinging, state.error])

    const startOutgoingCall = useCallback(async (recipientName: string, conversationId: number, recipientAvatar?: string) => {
        try {
            setState(prev => ({
                ...prev,
                isOutgoingCallOpen: true,
                isIncomingCallOpen: false,
                recipientName,
                recipientAvatar,
                conversationId,
                callDuration: 0,
                isRinging: true,
                isConnecting: true,
                error: undefined
            }))

            // G·ªçi API ƒë·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi video
            const response: VideoCallResponse = await videoCallService.startVideoCall(conversationId)

            if (response.success) {
                setState(prev => ({
                    ...prev,
                    sessionId: response.data.videoCallSessionId,
                    livekitToken: response.data.livekitToken,
                    livekitServerUrl: response.data.livekitServerUrl,
                    isConnecting: false
                }))

                console.log('Video call started successfully:', response.data)
            } else {
                throw new Error(response.message || 'Failed to start video call')
            }
        } catch (error) {
            console.error('Error starting video call:', error)
            const errorMessage = error instanceof Error ? error.message : 'Failed to start video call'

            setState(prev => ({
                ...prev,
                error: errorMessage,
                isConnecting: false
            }))

            // Kh√¥ng t·ª± ƒë·ªông ƒë√≥ng modal n·∫øu c√≥ l·ªói - ƒë·ªÉ user c√≥ th·ªÉ retry
        }
    }, [])

    const startIncomingCall = useCallback((callerName: string, sessionId: string, callerAvatar?: string) => {
        setState(prev => ({
            ...prev,
            isIncomingCallOpen: true,
            isOutgoingCallOpen: false,
            callerName,
            callerAvatar,
            sessionId,
            callDuration: 0,
            isRinging: true,
            error: undefined
        }))
    }, [])

    const rejectCall = useCallback(async () => {
        try {
            console.log('‚ùå Rejecting video call...')

            // Ch·ªâ g·ªçi API n·∫øu c√≥ sessionId th·ª±c t·∫ø (kh√¥ng ph·∫£i test)
            if (state.sessionId && !state.sessionId.includes('test-')) {
                await videoCallService.rejectVideoCall(state.sessionId)
                console.log('‚úÖ Call rejected successfully')
            } else {
                console.log('üß™ Test call rejected (no API call)')
            }

            // ƒê√≥ng modal v√† reset state
            setState(prev => ({
                ...prev,
                isIncomingCallOpen: false,
                isOutgoingCallOpen: false,
                isRinging: false,
                callDuration: 0,
                sessionId: undefined,
                livekitToken: undefined,
                livekitServerUrl: undefined,
                isConnecting: false,
                error: undefined
            }))

            // G·ªçi callback n·∫øu c√≥
            if (onCallRejected) {
                onCallRejected()
            }
        } catch (error) {
            console.error('Error rejecting video call:', error)
            setState(prev => ({ ...prev, error: error instanceof Error ? error.message : 'Unknown error' }))
        }
    }, [state.sessionId, onCallRejected])

    const cancelCall = useCallback(async () => {
        try {
            console.log('üö´ Cancelling video call...')

            // Ch·ªâ g·ªçi API n·∫øu c√≥ sessionId th·ª±c t·∫ø (kh√¥ng ph·∫£i test)
            if (state.sessionId && !state.sessionId.includes('test-')) {
                await videoCallService.endVideoCall(state.sessionId)
                console.log('‚úÖ Call ended successfully')
            } else {
                console.log('üß™ Test call cancelled (no API call)')
            }

            // ƒê√≥ng modal v√† reset state
            setState(prev => ({
                ...prev,
                isOutgoingCallOpen: false,
                isIncomingCallOpen: false,
                isRinging: false,
                callDuration: 0,
                sessionId: undefined,
                livekitToken: undefined,
                livekitServerUrl: undefined,
                isConnecting: false,
                error: undefined
            }))

            // G·ªçi callback n·∫øu c√≥
            if (onCallEnded) {
                onCallEnded()
            }
        } catch (error) {
            console.error('Error ending video call:', error)
            setState(prev => ({ ...prev, error: error instanceof Error ? error.message : 'Unknown error' }))
        }
    }, [state.sessionId, onCallEnded])

    const acceptCall = useCallback(async () => {
        try {
            console.log('‚úÖ Accepting video call...')

            if (state.sessionId) {
                // G·ªçi API ƒë·ªÉ ch·∫•p nh·∫≠n cu·ªôc g·ªçi
                const response = await videoCallService.acceptVideoCall(state.sessionId)

                // C·∫≠p nh·∫≠t state v·ªõi th√¥ng tin LiveKit
                setState(prev => ({
                    ...prev,
                    livekitToken: response.data.livekitToken,
                    livekitServerUrl: response.data.livekitServerUrl,
                    isConnecting: false,
                    error: undefined
                }))

                console.log('‚úÖ Call accepted successfully')

                // G·ªçi callback
                onCallAccepted()
            }
        } catch (error) {
            console.error('Error accepting video call:', error)
            setState(prev => ({
                ...prev,
                error: error instanceof Error ? error.message : 'Unknown error',
                isConnecting: false
            }))
        }
    }, [state.sessionId])

    const closeModals = useCallback(() => {
        setState(prev => ({
            ...prev,
            isOutgoingCallOpen: false,
            isIncomingCallOpen: false,
            isRinging: false,
            callDuration: 0,
            isConnecting: false,
            error: undefined
        }))
    }, [])

    // Retry functionality
    const retryOutgoingCall = useCallback(() => {
        if (state.conversationId) {
            console.log('Retrying outgoing call...')
            startOutgoingCall(state.recipientName, state.conversationId, state.recipientAvatar)
        }
    }, [state.conversationId, state.recipientName, state.recipientAvatar, startOutgoingCall])

    const actions: VideoCallActions = {
        startOutgoingCall,
        startIncomingCall,
        cancelCall,
        acceptCall,
        rejectCall,
        closeModals,
        onCallAccepted,
        onCallRejected,
        onCallEnded,
        retryOutgoingCall
    }

    return [state, actions]
}
